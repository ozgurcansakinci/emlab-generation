"SpotMarketCash", "ElectricitySpotMarket","[v.name, v.cash];",

"CommodityMarketCash", "CommodityMarket","[v.name, v.cash];",

"ProducerCash", "EnergyProducer", "[v.name, v.cash]",

"BankCash", "BigBank", "[v.name, v.cash]",

"CommoditySupplierCash", "CommoditySupplier", "[v.name, v.cash]",

"EnergyConsumerCash", "EnergyConsumer", "[v.name, v.cash]",

"GovernmentCash", "Government", "[v.name, v.cash]",

"NationalGovernmentCash", "NationalGovernment", "[v.name, v.cash]",

"PowerPlantMaintainerCash", "PowerPlantMaintainer", "[v.name, v.cash]",

"PowerPlantManufacturerCash", "PowerPlantManufacturer", "[v.name, v.cash]",

"Avg_El_PricesinEURpMWh", "Zone", "cp = v.in('ZONE').out('MARKET_INFORMATION_POINT').filter{it.time==tick}
result=[]
for(point in cp){
	sum=0;
	for(int i=0; i<point.marketPrice.length; i++){sum=sum+point.marketPrice[i]};
	result.add([v.name, sum / point.marketPrice.length]);
}
return result",

"NationalTotalProductioninMWh", "Zone", "powerplants = v.in('REGION').in('LOCATION')

return [v.name, powerplants.in('PPDPANNUAL_POWERPLANT').sum{it.yearlySupply}]",

"Total_EnergyServedinMWh", "Zone", "cp = v.in('ZONE').out('MARKET_INFORMATION_POINT').filter{it.time==tick}
result=[]
for(point in cp){
	sum=0;
	for(int i=0; i<point.marketSupply.length; i++){sum=sum+point.marketSupply[i]};
	result.add([v.name, sum]);
}
return result",

"Total_DemandinMWh", "Zone", "cp = v.in('ZONE').out('MARKET_INFORMATION_POINT').filter{it.time==tick}
result=[]
for(point in cp){
	sum=0;
	for(int i=0; i<point.marketDemand.length; i++){sum=sum+point.marketDemand[i]};
	result.add([v.name, sum]);
}
return result",

"WelfareLossThroughENSInEur", "Zone", "cp = v.in('ZONE').out('MARKET_INFORMATION_POINT').filter{it.time==tick}
result=[]
for(point in cp){
	volumeOfLostLoad  = 0;
	for(int i=0; i<point.valueOfLostLoad.length; i++){volumeOfLostLoad=volumeOfLostLoad+point.valueOfLostLoad[i]};
	voll = v.in('ZONE').next().valueOfLostLoad
	result.add([v.name, volumeOfLostLoad*voll]);
}
return result",

"EnergyNotServedinMWh", "Zone", "cp = v.in('ZONE').out('MARKET_INFORMATION_POINT').filter{it.time==tick}
result=[]
for(point in cp){
	volumeOfLostLoad  = 0;
	for(int i=0; i<point.valueOfLostLoad.length; i++){volumeOfLostLoad=volumeOfLostLoad+point.valueOfLostLoad[i]};
	result.add([v.name, volumeOfLostLoad]);
}
return result",

"ShortageInHours", "Zone", "cp = v.in('ZONE').out('MARKET_INFORMATION_POINT').filter{it.time==tick}
result=[]
for(point in cp){
	shortage  = 0;
	for(int i=0; i<point.valueOfLostLoad.length; i++){if(point.valueOfLostLoad[i]>0){shortage=shortage+1;}};
	result.add([v.name, shortage]);
}
return result",

"CO2Emissions_inTonpA", "DecarbonizationModel", "ppdps=g.idx('__types__')[[className:'emlab.gen.domain.market.electricity.PpdpAnnual']].propertyFilter('time', FilterPipe.Filter.EQUAL, tick).filter{it.status>=2}.collect();
co2Emissions = 0
for(plan in ppdps){
co2Emissions+=plan.yearlyEmissions;
}
return co2Emissions",

"CO2Emissions_inTonpA_perZone", "Zone", "ppdps=v.in('REGION').in('LOCATION').in('PPDPANNUAL_POWERPLANT').propertyFilter('time', FilterPipe.Filter.EQUAL, tick).filter{it.status>=2}.collect();
co2Emissions = 0
for(plan in ppdps){
co2Emissions+=plan.yearlyEmissions;
}
return co2Emissions",

"EUCO2PriceFloor", "Government", "try{price = v.out('MINCO2PRICE_TREND').collect{f.getTrendValue(it, tick)}[0];} catch(Exception e){  
price = v.out('MINCO2PRICE_TREND').timeSeries.next()[tick.toInteger()];};
return ['EU CO2 price floor', price];",

"CO2Tax", "Government", "try{price = v.out('CO2TAX_TREND').collect{f.getTrendValue(it, tick)}[0];} catch(Exception e){  
price = v.out('CO2TAX_TREND').timeSeries.next()[tick.toInteger()];}
return price",

"FuelPricesPerGJ", "DecarbonizationModel", "fuels = g.idx('__types__')[[className:'emlab.gen.domain.technology.Substance']].filter{it.name != 'Electricity' && it.name != 'CO2'}
result = []
for(v in fuels){
      price = v.in('SUBSTANCE_MARKET').in('MARKET_POINT').filter{it.time == tick}.collect{it.price};
      density = v.energyDensity;
      inGJ = price[0] / density;
      result.add([v.name,inGJ]);}
      return result",
      
"HistoricalCVar", "PowerGeneratingTechnology", "fr = v.in('TECHNOLOGY').in('FINANCIALREPORT_POWERPLANT').propertyFilter('time', FilterPipe.Filter.GREATER_THAN_EQUAL, tick-2).propertyFilter('time', FilterPipe.Filter.LESS_THAN_EQUAL, tick).propertyFilter('powerPlantStatus', FilterPipe.Filter.EQUAL, 1);
cvar=0;
if(fr.hasNext()){fr=fr.sort{it.overallRevenue-it.variableCosts}._().toList();
length=fr.size(); fiveQuantile=(int)length*0.05;cvar=(long) 0;
for(int i=0; i<=fiveQuantile; i++){cvar=cvar+(fr[i].overallRevenue-fr[i].variableCosts)/fr[i].out('FINANCIALREPORT_POWERPLANT').actualNominalCapacity.next()};
cvar=cvar/((double)(fiveQuantile+1));}
return [v.name,cvar];",

"AggregateFinances", "DecarbonizationModel", "flows = n.getNodes('CashFlow');
groups = flows.groupBy{it.type}
result = [];
totalCosts = 0;
totalRevenue = 0;
totalSpotRevenue = 0;
totalLTCRevenue = 0;
totalCMRevenue = 0;
totalRESRevenue=0;
totalCO2HedgingRevenue=0;
totalTargetInvCosts = 0;
totalTargetInvRevenue = 0;
totalTargetInvSpotRevenue = 0;
totalTargetInvLTCRevenue = 0;
totalTargetInvCMRevenue = 0;
totalTargetInvRESRevenue=0;
totalTargetInvCO2HedgingRevenue=0;
hedgingFlows=[]
for (key in groups.keySet()) {
    if (key<3 || (key>9 && key!=12)) {
        for (flow in groups[key]) {
            if (flow.time != tick) continue;
            if (flow.out('TO_AGENT').collect{it.__type__.contains('EnergyProducer')}[0]) {
                totalRevenue += flow.money;
            } else if(flow.out('TO_AGENT').collect{it.__type__.contains('TargetInvestor')}[0]){
                totalTargetInvRevenue += flow.money;
            }
        }
    } else if(key!=12) {
        for (flow in groups[key]) {
            if (flow.time != tick) continue;
            if (flow.out('FROM_AGENT').collect{it.__type__.contains('EnergyProducer')}[0]) {
                totalCosts += flow.money;
            } else if(flow.out('FROM_AGENT').collect{it.__type__.contains('TargetInvestor')}[0]){
                totalTargetInvCosts += flow.money;
            }
        }
    }  
     if (key==1) {
        for (flow in groups[key]) {
            if (flow.time != tick) continue;
            if (flow.out('TO_AGENT').collect{it.__type__.contains('EnergyProducer')}[0]) {
                totalSpotRevenue += flow.money;
            } else if(flow.out('TO_AGENT').collect{it.__type__.contains('TargetInvestor')}[0]){
                totalTargetInvSpotRevenue += flow.money;
            }
        }
    }
     if (key==2) {
        for (flow in groups[key]) {
            if (flow.time != tick) continue;
            if (flow.out('TO_AGENT').collect{it.__type__.contains('EnergyProducer')}[0]) {
                totalLTCRevenue += flow.money;
            } else if(flow.out('TO_AGENT').collect{it.__type__.contains('TargetInvestor')}[0]){
                totalTargetInvLTCRevenue += flow.money;
            }
        }
    }
         if (key==11) {
        for (flow in groups[key]) {
            if (flow.time != tick) continue;
            if (flow.out('TO_AGENT').collect{it.__type__.contains('EnergyProducer')}[0]) {
                totalCMRevenue += flow.money;
            } else if(flow.out('TO_AGENT').collect{it.__type__.contains('TargetInvestor')}[0]){
                totalTargetInvCMRevenue += flow.money;
            }
        }
    }
             if (key==10) {
        for (flow in groups[key]) {
            if (flow.time != tick) continue;
            if (flow.out('TO_AGENT').collect{it.__type__.contains('EnergyProducer')}[0]) {
                totalRESRevenue += flow.money;
            } else if(flow.out('TO_AGENT').collect{it.__type__.contains('TargetInvestor')}[0]){
                totalTargetInvRESRevenue += flow.money;
            }
        }
    }
if (key==12) {
        for (flow in groups[key]) {
            if (flow.time != tick) continue;
            hedgingFlows.add(flow)
            if (flow.out('TO_AGENT').collect{it.__type__.contains('EnergyProducer')}[0])  {
                totalCO2HedgingRevenue += flow.money;
                totalRevenue+= flow.money;
            } else if(flow.out('TO_AGENT').collect{it.__type__.contains('TargetInvestor')}[0]){
                totalTargetInvCO2HedgingRevenue += flow.money;
            }
            if (flow.out('FROM_AGENT').collect{it.__type__.contains('EnergyProducer') }[0]) {
                //totalCO2HedgingRevenue -= flow.money;
                totalCosts+= flow.money;
            }
        }
        }
}
result.add(['Total Revenue', totalRevenue]);
result.add(['Revenue LTC', totalLTCRevenue]);
result.add(['Revenue Spot', totalSpotRevenue]);
result.add(['Revenue CM', totalCMRevenue])
result.add(['Revenue RES',totalRESRevenue])
result.add(['Revenue CO2Hedge', totalCO2HedgingRevenue]);
result.add(['Profit', totalRevenue - totalCosts]);
result.add(['TI Revenue', totalTargetInvRevenue]);
result.add(['TI Revenue LTC', totalTargetInvLTCRevenue]);
result.add(['TI Revenue Spot', totalTargetInvSpotRevenue]);
result.add(['TI Revenue CM', totalTargetInvCMRevenue])
result.add(['TI Revenue RES',totalTargetInvRESRevenue])
result.add(['TI Revenue CO2Hedge', totalTargetInvCO2HedgingRevenue]);
result.add(['TI Profit', totalTargetInvRevenue - totalTargetInvCosts]);
return result;",

"PricesPerSegment", "DecarbonizationModel","points = g.idx('__types__')[[className:'emlab.gen.domain.market.electricity.TimeSeriesToLDCClearingPoint']].propertyFilter('time', FilterPipe.Filter.EQUAL, tick)
 results = []
for(pcp in points){
    results.add(['Segment'+pcp.out('PRICE_POINT').segmentID.next(),pcp.price])
}
return results",

"TABLE_MarketInformation", "DecarbonizationModel", "points = g.idx('__types__')[[className:'emlab.gen.domain.market.YearlySegmentClearingPointMarketInformation']].propertyFilter('time', FilterPipe.Filter.EQUAL, tick)
finalResult = []
headers=['tick','name','price','supply',',demand','voll','storageCharging','storageDischarging','soc','elasticDemand']
finalResult.add(headers)
for(v in points){
for(int i=0;i<v.marketPrice.length;i++){finalResult.add([v.marketSupply[i]])}
}
return finalResult",







