"SpotMarketCash", "ElectricitySpotMarket","[v.name, v.cash];",

"CommodityMarketCash", "CommodityMarket","[v.name, v.cash];",

"ProducerCash", "EnergyProducer", "[v.name, v.cash]",

"BankCash", "BigBank", "[v.name, v.cash]",

"CommoditySupplierCash", "CommoditySupplier", "[v.name, v.cash]",

"EnergyConsumerCash", "EnergyConsumer", "[v.name, v.cash]",

"GovernmentCash", "Government", "[v.name, v.cash]",

"NationalGovernmentCash", "NationalGovernment", "[v.name, v.cash]",

"PowerPlantMaintainerCash", "PowerPlantMaintainer", "[v.name, v.cash]",

"PowerPlantManufacturerCash", "PowerPlantManufacturer", "[v.name, v.cash]",

"StakeholderCash", "Stakeholder", "[v.name, v.cash]",

"ProducerCosts", "DecarbonizationModel", "flows = n.getNodes('CashFlow');
groups = flows.groupBy{it.type}
result = [];
allKeys = []
for(i in 0..18)
    allKeys.add(i)
usedKeys=[]
for (key in allKeys) {
    usedKeys.add(key)
    sum = 0;
    if(key in groups.keySet()){
         for (flow in groups[key]) {
        if (flow.time != tick) continue;
        if (flow.out('FROM_AGENT').collect{it.__type__.contains('EnergyProducer')}[0]) {
            sum += flow.money;
            }
        }
    } 
    name='Unspecified';
    if(key==0){name='Unclassified';}
    if(key==1){name='Electricity spot';}
    if(key==2){name='Electricity ltc';}
    if(key==3){name='Fixed O&M';}
    if(key==4){name='Commodity';}
    if(key==5){name='CO2 tax';}
    if(key==6){name='CO2 auction';}
    if(key==7){name='Loan';}
    if(key==8){name='Downpayment';}
    if(key==9){name='National CO2 MinPrice';}
    if(key==10){name='Strategic Reserve';}
    if(key==11){name='Capacity Market';}
    if(key==12){name='CO2 Hedging';}
    if(key==14){name='Storage O&M';}
    if(key==15){name='Storage Inc Inv';}
    if(key==16){name='Storage Inv';}
    if(key==17){name='Stakeholder Div';}
    if(key==18){name='Storage Cap Rev';}
    result.add([name, sum]);
} 
return result;",

"TotalAnnualConsumptioninMWh", "DecarbonizationModel", "ppdps = g.idx('__types__')[[className:'emlab.gen.domain.market.electricity.PpdpAnnual']].filter{it.status == 2};
productionsum  = 0;
for(ppdp in ppdps){
    productionsum += ppdp.yearlySupply;
}
return productionsum;",

"GenerationPerTechnology", "PowerGeneratingTechnology", "sum = 0;
ppdps = v.in('TECHNOLOGY').in('PPDPANNUAL_POWERPLANT').filter{it.time==tick && it.status>=2}
for(ppdp in ppdps){
    totalAmount = ppdp.getProperty('yearlySupply');
    sum = sum + totalAmount;
}
return [v.name, sum]",

"CapacityMarketDemandTarget", "Regulator", "name=v.out('OF_ZONE').collect{it.name}[0]
return [name, v.demandTarget]",

"CapacityMarketCrossBorderCapacity", "Regulator", "name=v.out('OF_ZONE').collect{it.name}[0]
return [name, v.crossBorderContractedCapacity]",

"GenerationPerProducer", "EnergyProducer", "sum = 0;
ppdps = v.in('POWERPLANT_OWNER').in('PPDPANNUAL_POWERPLANT').filter{it.time==tick && it.status>=2}
for(ppdp in ppdps){
    totalAmount = ppdp.getProperty('yearlySupply');
    sum = sum + totalAmount;
}
return [v.name, sum]",

"Capacity_per_Technology", "PowerGeneratingTechnology", "ppdps= v.in('TECHNOLOGY').in('PPDPANNUAL_POWERPLANT').filter{it.time==tick && it.status>=2}
sum=0
for(ppdp in ppdps){
sum=sum+ppdp.yearlySupply
}
return [v.name,sum]",

"Avg_El_PricesinEURpMWh", "Zone", "cp = v.in('ZONE').out('MARKET_INFORMATION_POINT').filter{it.time==tick}
result=[]
for(point in cp){
	sum=0;
	for(int i=0; i<point.marketPrice.length; i++){sum=sum+point.marketPrice[i]};
	price=sum / point.marketPrice.length;
}
return [v.name,price]",

"NationalTotalProductioninMWh", "Zone", "powerplants = v.in('REGION').in('LOCATION')

return [v.name, powerplants.in('PPDPANNUAL_POWERPLANT').sum{it.yearlySupply}]",

"Total_EnergyServedinMWh", "Zone", "cp = v.in('ZONE').out('MARKET_INFORMATION_POINT').filter{it.time==tick}
for(point in cp){
	sum=0;
	for(int i=0; i<point.marketSupply.length; i++){sum=sum+point.marketSupply[i]};
}
return [v.name, sum]",

"Total_DemandinMWh", "Zone", "cp = v.in('ZONE').out('MARKET_INFORMATION_POINT').filter{it.time==tick}
for(point in cp){
	sum=0;
	for(int i=0; i<point.marketDemand.length; i++){sum=sum+point.marketDemand[i]};
}
return [v.name, sum]",

"WelfareLossThroughENSInEur", "Zone", "cp = v.in('ZONE').out('MARKET_INFORMATION_POINT').filter{it.time==tick}
for(point in cp){
	volumeOfLostLoad  = 0;
	for(int i=0; i<point.valueOfLostLoad.length; i++){volumeOfLostLoad=volumeOfLostLoad+point.valueOfLostLoad[i]};
	voll = v.in('ZONE').next().valueOfLostLoad
}
return [v.name, volumeOfLostLoad*voll]",

"EnergyNotServedinMWh", "Zone", "cp = v.in('ZONE').out('MARKET_INFORMATION_POINT').filter{it.time==tick}
for(point in cp){
	volumeOfLostLoad  = 0;
	for(int i=0; i<point.valueOfLostLoad.length; i++){volumeOfLostLoad=volumeOfLostLoad+point.valueOfLostLoad[i]};
}
return [v.name, volumeOfLostLoad]",

"ShortageInHours", "Zone", "cp = v.in('ZONE').out('MARKET_INFORMATION_POINT').filter{it.time==tick}
for(point in cp){
	shortage  = 0;
	for(int i=0; i<point.valueOfLostLoad.length; i++){if(point.valueOfLostLoad[i]>0){shortage=shortage+1;}};
}
return [v.name, shortage]",

"CO2Emissions_inTonpA", "DecarbonizationModel", "ppdps=g.idx('__types__')[[className:'emlab.gen.domain.market.electricity.PpdpAnnual']].propertyFilter('time', FilterPipe.Filter.EQUAL, tick).filter{it.status>=2}.collect();
co2Emissions = 0
for(plan in ppdps){
co2Emissions+=plan.yearlyEmissions;
}
return co2Emissions",

"CO2Emissions_inTonpA_perZone", "Zone", "ppdps=v.in('REGION').in('LOCATION').in('PPDPANNUAL_POWERPLANT').propertyFilter('time', FilterPipe.Filter.EQUAL, tick).filter{it.status>=2}.collect();
co2Emissions = 0
for(plan in ppdps){
co2Emissions+=plan.yearlyEmissions;
}
return [v.name,co2Emissions]",

"EUCO2PriceFloor", "Government", "try{price = v.out('MINCO2PRICE_TREND').collect{f.getTrendValue(it, tick)}[0];} catch(Exception e){  
price = v.out('MINCO2PRICE_TREND').timeSeries.next()[tick.toInteger()];};
return ['EU CO2 price floor', price];",

"CO2Tax", "Government", "try{price = v.out('CO2TAX_TREND').collect{f.getTrendValue(it, tick)}[0];} catch(Exception e){  
price = v.out('CO2TAX_TREND').timeSeries.next()[tick.toInteger()];}
return price",

"CO2Price", "DecarbonizationModel", "cps = g.idx('__types__')[[className:'emlab.gen.domain.market.electricity.YearlySegmentClearingPointMarketInformation']].propertyFilter('time', FilterPipe.Filter.EQUAL, tick)
for(point in cps){price=point.CO2Price}
return [v.name,price]",

"FuelPricesPerGJ", "DecarbonizationModel", "fuels = g.idx('__types__')[[className:'emlab.gen.domain.technology.Substance']].filter{it.name != 'Electricity' && it.name != 'CO2'}
result = []
for(v in fuels){
      price = v.in('SUBSTANCE_MARKET').in('MARKET_POINT').filter{it.time == tick}.collect{it.price};
      density = v.energyDensity;
      inGJ = price[0] / density;
      result.add([v.name,inGJ]);}
      return result",
      
"HistoricalCVar", "PowerGeneratingTechnology", "fr = v.in('TECHNOLOGY').in('FINANCIALREPORT_POWERPLANT').propertyFilter('time', FilterPipe.Filter.GREATER_THAN_EQUAL, tick-2).propertyFilter('time', FilterPipe.Filter.LESS_THAN_EQUAL, tick).propertyFilter('powerPlantStatus', FilterPipe.Filter.EQUAL, 1);
cvar=0;
if(fr.hasNext()){fr=fr.sort{it.overallRevenue-it.variableCosts}._().toList();
length=fr.size(); fiveQuantile=(int)length*0.05;cvar=(long) 0;
for(int i=0; i<=fiveQuantile; i++){cvar=cvar+(fr[i].overallRevenue-fr[i].variableCosts)/fr[i].out('FINANCIALREPORT_POWERPLANT').actualNominalCapacity.next()};
cvar=cvar/((double)(fiveQuantile+1));}
return [v.name,cvar];",

"AggregateFinances", "DecarbonizationModel", "flows = n.getNodes('CashFlow');
groups = flows.groupBy{it.type}
result = [];
totalCosts = 0;
totalRevenue = 0;
totalSpotRevenue = 0;
totalLTCRevenue = 0;
totalCMRevenue = 0;
totalRESRevenue=0;
totalStorageRevenue=0;
totalStorageOMCost=0;
totalStorageInvCost=0;
totalStorageProfit=0;
totalCO2HedgingRevenue=0;
totalTargetInvCosts = 0;
totalTargetInvRevenue = 0;
totalTargetInvSpotRevenue = 0;
totalTargetInvLTCRevenue = 0;
totalTargetInvCMRevenue = 0;
totalTargetInvRESRevenue=0;
totalTargetInvCO2HedgingRevenue=0;
totalStakeholderDividend=0;
totalStorageCapMarketRevenue=0;
hedgingFlows=[]
for (key in groups.keySet()) {
    if (key<3 || (key>9 && key!=12)) {
        for (flow in groups[key]) {
            if (flow.time != tick) continue;
            if (flow.out('TO_AGENT').collect{it.__type__.contains('EnergyProducer')}[0]) {
                totalRevenue += flow.money;
            } else if(flow.out('TO_AGENT').collect{it.__type__.contains('TargetInvestor')}[0]){
                totalTargetInvRevenue += flow.money;
            }
        }
    } else if(key!=12) {
        for (flow in groups[key]) {
            if (flow.time != tick) continue;
            if (flow.out('FROM_AGENT').collect{it.__type__.contains('EnergyProducer')}[0]) {
                totalCosts += flow.money;
            } else if(flow.out('FROM_AGENT').collect{it.__type__.contains('TargetInvestor')}[0]){
                totalTargetInvCosts += flow.money;
            }
        }
    }  
     if (key==1) {
        for (flow in groups[key]) {
            if (flow.time != tick) continue;
            if (flow.out('TO_AGENT').collect{it.__type__.contains('EnergyProducer')}[0]) {
                totalSpotRevenue += flow.money;
            } else if(flow.out('TO_AGENT').collect{it.__type__.contains('TargetInvestor')}[0]){
                totalTargetInvSpotRevenue += flow.money;
            }
        }
    }
     if (key==2) {
        for (flow in groups[key]) {
            if (flow.time != tick) continue;
            if (flow.out('TO_AGENT').collect{it.__type__.contains('EnergyProducer')}[0]) {
                totalLTCRevenue += flow.money;
            } else if(flow.out('TO_AGENT').collect{it.__type__.contains('TargetInvestor')}[0]){
                totalTargetInvLTCRevenue += flow.money;
            }
        }
    }
         if (key==11) {
        for (flow in groups[key]) {
            if (flow.time != tick) continue;
            if (flow.out('TO_AGENT').collect{it.__type__.contains('EnergyProducer')}[0]) {
                totalCMRevenue += flow.money;
            } else if(flow.out('TO_AGENT').collect{it.__type__.contains('TargetInvestor')}[0]){
                totalTargetInvCMRevenue += flow.money;
            }
        }
    }
             if (key==10) {
        for (flow in groups[key]) {
            if (flow.time != tick) continue;
            if (flow.out('TO_AGENT').collect{it.__type__.contains('EnergyProducer')}[0]) {
                totalRESRevenue += flow.money;
            } else if(flow.out('TO_AGENT').collect{it.__type__.contains('TargetInvestor')}[0]){
                totalTargetInvRESRevenue += flow.money;
            }
        }
    }
    if (key==13) {
        for (flow in groups[key]) {
            if (flow.time != tick) continue;
            if (flow.out('TO_AGENT').collect{it.__type__.contains('EnergyProducer')}[0]) {
                totalStorageRevenue += flow.money;
            } 
        }
    }
    if (key==14) {
        for (flow in groups[key]) {
            if (flow.time != tick) continue;
            if (flow.out('TO_AGENT').collect{it.__type__.contains('EnergyProducer')}[0]) {
                totalStorageOMCost += flow.money;
            } 
        }
    }
    if (key==16) {
        for (flow in groups[key]) {
            if (flow.time != tick) continue;
            if (flow.out('FROM_AGENT').collect{it.__type__.contains('EnergyProducer')}[0]) {
                totalStorageInvCost += flow.money;
            } 
        }
    }
    if (key==15) {
        for (flow in groups[key]) {
            if (flow.time != tick) continue;
            if (flow.out('FROM_AGENT').collect{it.__type__.contains('EnergyProducer')}[0]) {
                totalStorageInvCost += flow.money;
            } 
        }
    }
    if (key==17) {
        for (flow in groups[key]) {
            if (flow.time != tick) continue;
            if (flow.out('FROM_AGENT').collect{it.__type__.contains('EnergyProducer')}[0]) {
                totalStakeholderDividend += flow.money;
            } 
        }
    }
    if (key==18) {
        for (flow in groups[key]) {
            if (flow.time != tick) continue;
            if (flow.out('TO_AGENT').collect{it.__type__.contains('EnergyProducer')}[0]) {
                totalStorageCapMarketRevenue += flow.money;
            } 
        }
    }
	if (key==12) {
        for (flow in groups[key]) {
            if (flow.time != tick) continue;
            hedgingFlows.add(flow)
            if (flow.out('TO_AGENT').collect{it.__type__.contains('EnergyProducer')}[0])  {
                totalCO2HedgingRevenue += flow.money;
                totalRevenue+= flow.money;
            } else if(flow.out('TO_AGENT').collect{it.__type__.contains('TargetInvestor')}[0]){
                totalTargetInvCO2HedgingRevenue += flow.money;
            }
            if (flow.out('FROM_AGENT').collect{it.__type__.contains('EnergyProducer') }[0]) {
                //totalCO2HedgingRevenue -= flow.money;
                totalCosts+= flow.money;
            }
        }
        }
}
result.add(['Total Revenue', totalRevenue]);
result.add(['Revenue LTC', totalLTCRevenue]);
result.add(['Revenue Spot', totalSpotRevenue]);
result.add(['Revenue CM', totalCMRevenue])
result.add(['Revenue RES',totalRESRevenue])
result.add(['Revenue CO2Hedge', totalCO2HedgingRevenue]);
result.add(['Revenue Storage',totalStorageRevenue]);
result.add(['Revenue Storage Capacity Market',totalStorageCapMarketRevenue]);
result.add(['Inv Cost Storage',totalStorageInvCost]);
result.add(['Profit Storage',totalStorageRevenue-totalStorageOMCost])
result.add(['Profit', totalRevenue - totalCosts]);
result.add(['Stakeholder Dividend',totalStakeholderDividend]);
result.add(['TI Revenue', totalTargetInvRevenue]);
result.add(['TI Revenue LTC', totalTargetInvLTCRevenue]);
result.add(['TI Revenue Spot', totalTargetInvSpotRevenue]);
result.add(['TI Revenue CM', totalTargetInvCMRevenue])
result.add(['TI Revenue RES',totalTargetInvRESRevenue])
result.add(['TI Revenue CO2Hedge', totalTargetInvCO2HedgingRevenue]);
result.add(['TI Profit', totalTargetInvRevenue - totalTargetInvCosts]);
return result;",

"TABLE_ProducerProfits", "DecarbonizationModel", "producers = g.idx('__types__')[[className:'emlab.gen.domain.agent.EnergyProducer']]
result=[]
header=['Producer Name','Type','Money'];
result.add(header);
for(producer in producers){
flows = producer.in('TO_AGENT').filter{it.time==tick}
totalSpotProfit=0;
totalLTCProfit=0;
totalCMProfit=0;
totalStorageProfit=0;
totalStorageCMProfit=0;
for(flow in flows){
    if(flow.type == 1){totalSpotProfit=totalSpotProfit+flow.money};
    if(flow.type == 2){totalLTCProfit=totalLTCProfit+flow.money}
    if(flow.type == 11){totalCMProfit=totalCMProfit+flow.money}
    if(flow.type == 13){totalStorageProfit=totalStorageProfit+flow.money}
    if(flow.type == 18){totalStorageCMProfit=totalStorageCMProfit+flow.money}
}
result.add([producer.name,'Total Spot Market Profit',totalSpotProfit]);
result.add([producer.name,'Total Spot Market LTC Profit',totalLTCProfit]);
result.add([producer.name,'Total Capacity Market Profit',totalCMProfit]);
result.add([producer.name,'Total Storage Profit',totalStorageProfit]);
result.add([producer.name,'Total Storage Capacity Market Profit',totalStorageCMProfit]);
}
return result",

"TABLE_ProducerCosts", "DecarbonizationModel", "producers = g.idx('__types__')[[className:'emlab.gen.domain.agent.EnergyProducer']]
result=[]
header=['Producer Name','Type','Money'];
result.add(header);
for(producer in producers){
flows = producer.in('FROM_AGENT').filter{it.time==tick}
totalCost3=0;
totalCost4=0;
totalCost5=0;
totalCost7=0;
totalCost8=0;
totalCost9=0;
totalCost14=0;
totalCost15=0;
totalCost16=0;
totalCost17=0;
for(flow in flows){
    if(flow.type == 3){totalCost3=totalCost3+flow.money};
    if(flow.type == 4){totalCost4=totalCost4+flow.money}
    if(flow.type == 5){totalCost5=totalCost5+flow.money}
    if(flow.type == 7){totalCost7=totalCost7+flow.money}
    if(flow.type == 8){totalCost8=totalCost8+flow.money}
    if(flow.type == 9){totalCost9=totalCost9+flow.money}
    if(flow.type == 14){totalCost14=totalCost14+flow.money}
    if(flow.type == 15){totalCost15=totalCost15+flow.money}
    if(flow.type == 16){totalCost16=totalCost16+flow.money}
    if(flow.type == 17){totalCost17=totalCost17+flow.money}
}
result.add([producer.name,'Total Fixed OM Cost',totalCost3]);
result.add([producer.name,'Total Fuel Cost',totalCost4]);
result.add([producer.name,'Total CO2 Tax',totalCost5]);
result.add([producer.name,'Total Loan',totalCost7]);
result.add([producer.name,'Total Downpayment',totalCost8]);
result.add([producer.name,'Total National Min CO2',totalCost9]);
result.add([producer.name,'Total Storage OM',totalCost14]);
result.add([producer.name,'Total Incremental Storage CC Capital Cost',totalCost15]);
result.add([producer.name,'Total Storage Investment',totalCost16]);
result.add([producer.name,'Total Stakeholder Dividend',totalCost17]);
}
return result",

"TABLE_PriceVolumeLengthInHoursPerSegment", "DecarbonizationModel","points = g.idx('__types__')[[className:'emlab.gen.domain.market.electricity.TimeSeriesToLDCClearingPoint']].propertyFilter('time', FilterPipe.Filter.EQUAL, tick)
 results = []
 header=['Tick','Market','Segment Name','Price','Residual Load','Demand','Generation','Length for Residual','Length for Demand','Length for Generation'];
results.add(header);
for(pcp in points){
	lengthInHoursDLDC=pcp.out('PRICE_POINT').collect{it.lengthInHoursDLDCForCapacityMarket}[0];
	lengthInHoursTotalGLDC=pcp.out('PRICE_POINT').collect{it.lengthInHoursTotalGLDCForInvestmentRole}[0];
	dldc=pcp.out('PRICE_POINT').in('SEGMENTLOAD_SEGMENT').collect{it.demandLDC}[0];
	totalGLDC=pcp.out('PRICE_POINT').in('SEGMENTLOAD_SEGMENT').collect{it.generationLDC}[0];
    results.add([tick,pcp.out('MARKET_POINT').collect{it.name}[0],'Segment'+pcp.out('PRICE_POINT').segmentID.next(),pcp.price,pcp.volume,dldc,totalGLDC,pcp.out('PRICE_POINT').collect{it.lengthInHoursGLDCForInvestmentRole}[0],lengthInHoursDLDC,lengthInHoursTotalGLDC])
}
return results",

"TABLE_MarketInformationForSpecificTick", "DecarbonizationModel", "cps = g.idx('__types__')[[className:'emlab.gen.domain.market.electricity.YearlySegmentClearingPointMarketInformation']].propertyFilter('time', FilterPipe.Filter.EQUAL,(long)0)
finalResult = []
headers=['name','price','supply',',demand','voll','storageCharging','storageDischarging','soc','elasticDemand']
finalResult.add(headers)
for(v in cps){
tick=v.time
name=v.in('MARKET_INFORMATION_POINT').collect{it.name}[0]
for(int i=0;i<v.marketPrice.length;i++){
price=v.marketPrice[i]
supply=v.marketSupply[i]
demand=v.marketDemand[i]
voll=v.valueOfLostLoad[i]
if(v.in('MARKET_INFORMATION_POINT').collect{it.storageImplemented}[0]==true){
storageCharging=v.storageChargingInMW[i]
storageDischarging=v.storageDischargingInMW[i]
soc=v.stateOfChargeInMWh[i]}
else{storageCharging=0
storageDischarging=0
soc=0}
if(v.in('MARKET_INFORMATION_POINT').collect{it.dailyDemandResponseImplemented}[0]==true){
elasticDemand=v.elasticDemand[i]}
else{elasticDemand=0}
finalResult.add([name,price,supply,demand,voll,storageCharging,storageDischarging,soc,elasticDemand])
}
}
return finalResult;",

"TABLE_InelasticDemand", "DecarbonizationModel", "demand = g.idx('__types__')[[className:'emlab.gen.domain.market.electricity.YearlySegmentLoad']].out('HOURLYDEMAND_SEGMENT')
if(tick==0){
finalResult = []
headers=['tick','market','index','amount']
finalResult.add(headers)
for(dem in demand){
market=dem.in('HOURLYDEMAND_SEGMENT').in('ELECTRICITYSPOTMARKET_LOAD').collect{it.name}[0]
for(int i=0;i<dem.lengthInHours;i++){
amount=dem.hourlyArray[i]
finalResult.add([tick,market,i,amount])
}
}
return finalResult}
else{return []}",

"TABLE_ElasticDemand", "DecarbonizationModel", "demand = g.idx('__types__')[[className:'emlab.gen.domain.market.electricity.YearlySegmentLoad']].out('DAILYDEMAND_SEGMENT')
if(tick==0){
finalResult = []
headers=['tick','market','index','amount']
finalResult.add(headers)
for(dem in demand){
market=dem.in('DAILYDEMAND_SEGMENT').in('ELECTRICITYSPOTMARKET_LOAD').collect{it.name}[0]
for(int i=0;i<dem.lengthInHours;i++){
amount=dem.hourlyArray[i]
finalResult.add([tick,market,i,amount])
}
}
return finalResult}
else{return []}",

"TABLE_InitialPowerPlants", "DecarbonizationModel", "if(tick<1){
powerPlants=g.idx('__types__')[[className:'emlab.gen.domain.technology.PowerPlant']];
finalResult = [];
columnNames=['Name', 'Technology', 'Location', 'Age', 'Owner', 'Capacity', 'Efficiency']
finalResult.add(columnNames)
for(p in powerPlants){
name = p.name
technology = p.out('TECHNOLOGY').collect{it.name}[0]
location = p.out('LOCATION').collect{it.name}[0]
age = -p.constructionStartTime-p.actualLeadtime-p.actualPermittime
owner = p.out('POWERPLANT_OWNER').collect{it.name}[0]
capacity = p.actualNominalCapacity
efficiency = p.actualEfficiency
finalResult.add([name,technology,location,age,owner,capacity,efficiency])
}
return finalResult
}",

"TABLE_InvestmentInNonIntermittents", "DecarbonizationModel", "powerplants= g.idx('__types__')[[className:'emlab.gen.domain.technology.PowerPlant']].as('x').out('TECHNOLOGY').filter{it.intermittent==false}.back('x').filter{it.constructionStartTime==tick}
powerPlantResult=[]
headers=['tick','market','name']
powerPlantResult.add(headers)
for(pp in powerplants){
market=pp.out('LOCATION').out('REGION').collect{it.name}[0]
name=pp.name
powerPlantResult.add([tick,market,name])
}
if(powerPlantResult.isEmpty()){return 0};
return powerPlantResult;",

"TABLE_InvestmentInIntermittents", "DecarbonizationModel", "powerplants= g.idx('__types__')[[className:'emlab.gen.domain.technology.PowerPlant']].as('x').out('TECHNOLOGY').filter{it.intermittent==true}.back('x').filter{it.constructionStartTime==tick}
powerPlantResult=[]
headers=['tick','market','name']
powerPlantResult.add(headers)
for(pp in powerplants){
market=pp.out('LOCATION').out('REGION').collect{it.name}[0]
name=pp.name
powerPlantResult.add([tick,market,name])
}
if(powerPlantResult.isEmpty()){return 0};
return powerPlantResult;",

"TABLE_DismantledIntermittentPowerPlants", "DecarbonizationModel", "powerplants= g.idx('__types__')[[className:'emlab.gen.domain.technology.PowerPlant']].as('x').out('TECHNOLOGY').filter{it.intermittent==true}.back('x').filter{it.dismantleTime==tick}
powerPlantResult=[]
headers=['tick','market','name']
powerPlantResult.add(headers)
for(pp in powerplants){
market=pp.out('LOCATION').out('REGION').collect{it.name}[0]
name=pp.name
powerPlantResult.add([tick,market,name])
}
if(powerPlantResult.isEmpty()){return 0};
return powerPlantResult;",

"TABLE_DismantledThermalPowerPlants", "DecarbonizationModel", "powerplants= g.idx('__types__')[[className:'emlab.gen.domain.technology.PowerPlant']].as('x').out('TECHNOLOGY').filter{it.intermittent==false}.back('x').filter{it.dismantleTime==tick}
powerPlantResult=[]
headers=['tick','market','name']
powerPlantResult.add(headers)
for(pp in powerplants){
market=pp.out('LOCATION').out('REGION').collect{it.name}[0]
name=pp.name
powerPlantResult.add([tick,market,name])
}
if(powerPlantResult.isEmpty()){return 0};
return powerPlantResult;",

"TABLE_EmissionsPerHourForSpecificTick", "DecarbonizationModel", "cps = g.idx('__types__')[[className:'emlab.gen.domain.market.electricity.YearlySegmentClearingPointMarketInformation']].propertyFilter('time', FilterPipe.Filter.EQUAL, (long) 0)
result=[]
for(point in cps){
for(int i=0;i<point.co2EmissionsPerHour.length;i++){
result.add([i,point.co2EmissionsPerHour[i]])
}
}
return result",

"TABLE_CountryProdFinances", "DecarbonizationModel", "flows = n.getNodes('CashFlow');
groups = flows.groupBy{it.type}
markets=g.idx('__types__')[[className:'emlab.gen.domain.market.electricity.ElectricitySpotMarket']]
result = [];
for(market in markets){
marketName=market.out('ZONE').collect{it.name}[0];
result.add(['Market Name',marketName]);
totalCosts = 0;
totalRevenue = 0;
totalSpotRevenue = 0;
totalCMRevenue = 0;
totalCO2HedgingRevenue=0;
totalTargetInvCosts = 0;
totalTargetInvRevenue = 0;
totalTargetInvSpotRevenue = 0;
totalTargetInvCMRevenue = 0;
totalTargetInvCO2HedgingRevenue=0;
hedgingFlows=[]
for (key in groups.keySet()) {
    if (key<3 || (key>9 && key!=12)) {
        for (flow in groups[key]) {
            if (flow.time != tick) continue;
            if (flow.out('TO_AGENT').collect{it.__type__.contains('EnergyProducer')}[0] && flow.out('TO_AGENT').out('INVESTOR_MARKET').out('ZONE').collect{it.name.equals(marketName)}[0]) {
                totalRevenue += flow.money;
            } else if(flow.out('TO_AGENT').collect{it.__type__.contains('TargetInvestor') }[0] && flow.out('TO_AGENT').out('INVESTOR_MARKET').out('ZONE').collect{it.name.equals(marketName)}[0]){
                totalTargetInvRevenue += flow.money;
            }
        }
        
    } else if(key!=12) {
        for (flow in groups[key]) {
            if (flow.time != tick) continue;
            if (flow.out('FROM_AGENT').collect{it.__type__.contains('EnergyProducer')}[0] && flow.out('FROM_AGENT').out('INVESTOR_MARKET').out('ZONE').collect{it.name.equals(marketName)}[0]) {
                totalCosts += flow.money;
            } else if(flow.out('FROM_AGENT').collect{it.__type__.contains('TargetInvestor') }[0] && flow.out('FROM_AGENT').out('INVESTOR_MARKET').out('ZONE').collect{it.name.equals(marketName)}[0]){
                totalTargetInvCosts += flow.money;
            }
        }
    }
       
     if (key==1) {
        for (flow in groups[key]) {
            if (flow.time != tick) continue;
            if (flow.out('TO_AGENT').collect{it.__type__.contains('EnergyProducer')}[0] && flow.out('TO_AGENT').out('INVESTOR_MARKET').out('ZONE').collect{it.name.equals(marketName)}[0]) {
                totalSpotRevenue += flow.money;
            } else if(flow.out('TO_AGENT').collect{it.__type__.contains('TargetInvestor') }[0] && flow.out('TO_AGENT').out('INVESTOR_MARKET').out('ZONE').collect{it.name.equals(marketName)}[0]){
                totalTargetInvSpotRevenue += flow.money;
            }
        }
        
    }
         if (key==11) {
        for (flow in groups[key]) {
            if (flow.time != tick) continue;
            if (flow.out('TO_AGENT').collect{it.__type__.contains('EnergyProducer')}[0] && flow.out('TO_AGENT').out('INVESTOR_MARKET').out('ZONE').collect{it.name.equals(marketName)}[0]) {
                totalCMRevenue += flow.money;
            } else if(flow.out('TO_AGENT').collect{it.__type__.contains('TargetInvestor') }[0] && flow.out('TO_AGENT').out('INVESTOR_MARKET').out('ZONE').collect{it.name.equals(marketName)}[0]){
                totalTargetInvCMRevenue += flow.money;
            }
        }
        
    }

if (key==12) {
        for (flow in groups[key]) {
            if (flow.time != tick) continue;
            hedgingFlows.add(flow)
            if (flow.out('TO_AGENT').collect{it.__type__.contains('EnergyProducer')}[0] && flow.out('TO_AGENT').out('INVESTOR_MARKET').out('ZONE').collect{it.name.equals(marketName)}[0])  {
                totalCO2HedgingRevenue += flow.money;
                totalRevenue+= flow.money;
            } else if(flow.out('TO_AGENT').collect{it.__type__.contains('TargetInvestor') }[0] && flow.out('TO_AGENT').out('INVESTOR_MARKET').out('ZONE').collect{it.name.equals(marketName)}[0]){
                totalTargetInvCO2HedgingRevenue += flow.money;
            }
            if (flow.out('FROM_AGENT').collect{it.__type__.contains('EnergyProducer') }[0] && flow.out('FROM_AGENT').out('INVESTOR_MARKET').out('ZONE').collect{it.name.equals(marketName)}[0]) {
                totalCO2HedgingRevenue -= flow.money;
                totalCosts+= flow.money;
            }
        }
        }
}
result.add(['Total Revenue', totalRevenue]);
result.add(['Revenue Spot', totalSpotRevenue]);
result.add(['Revenue CM', totalCMRevenue])
result.add(['Revenue CO2Hedge', totalCO2HedgingRevenue]);
result.add(['Profit', totalRevenue - totalCosts]);
result.add(['TI Revenue', totalTargetInvRevenue]);
result.add(['TI Revenue Spot', totalTargetInvSpotRevenue]);
result.add(['TI Revenue CM', totalTargetInvCMRevenue])
result.add(['TI Revenue CO2Hedge', totalTargetInvCO2HedgingRevenue]);
result.add(['TI Profit', totalTargetInvRevenue - totalTargetInvCosts]);}
return result;",

"TABLE_ClearingPoints", "DecarbonizationModel", "points = g.idx('__types__')[[className:'emlab.gen.domain.market.ClearingPoint']].propertyFilter('time', FilterPipe.Filter.EQUAL, tick)
finalResult = []
headers=['tick','volume','price',',market']
finalResult.add(headers)
for(v in points){
finalResult.add([v.time, v.volume, v.price, v.out('MARKET_POINT').collect{it.name}[0]])
}
return finalResult",

"TABLE_CapacityClearingPoint", "DecarbonizationModel", "cps = g.idx('__types__')[[className:'emlab.gen.domain.market.capacity.CapacityClearingPoint']].filter{it.time==tick};
result=[]
headers=['tick','name','volume','price']
result.add(headers)
for(point in cps) result.add([tick,point.out('CAPACITY_MARKET').collect{it.name}[0],point.volume,point.price])
if(result.isEmpty()){return 0};
return result",

"TABLE_CapacityBidsAccepted", "DecarbonizationModel", "bids = g.idx('__types__')[[className:'emlab.gen.domain.market.capacity.CapacityDispatchPlan']].filter{it.time==tick}.filter{it.status>=2};
result=[]
headers=['tick','producer','market','type','amount','price','status']
result.add(headers)
for(bid in bids){
producer=bid.in('BIDDER').collect{it.name}[0]
market=bid.out('BIDDINGMARKET').collect{it.name}[0]
type=bid.out('CAPACITY_DISPATCHPLAN').collect{it.name}[0]
if(type==null){type=bid.out('CAPACITY_DISPATCHPLAN_STORAGE').collect{it.name}[0]}
amount=bid.amount
price=bid.price
status=bid.status
result.add([tick,producer,market,type,amount,price,status])}
return result;",

"TABLE_CapacityBidsFailed", "DecarbonizationModel", "bids = g.idx('__types__')[[className:'emlab.gen.domain.market.capacity.CapacityDispatchPlan']].filter{it.time==tick}.filter{it.status==-1};
result=[]
headers=['tick','producer','market','type','amount','price','status']
result.add(headers)
for(bid in bids){
producer=bid.in('BIDDER').collect{it.name}[0]
market=bid.out('BIDDINGMARKET').collect{it.name}[0]
type=bid.out('CAPACITY_DISPATCHPLAN').collect{it.name}[0]
if(type==null){type=bid.out('CAPACITY_DISPATCHPLAN_STORAGE').collect{it.name}[0]}
amount=bid.amount
price=bid.price
status=bid.status
result.add([tick,producer,market,type,amount,price,status])}
return result;",

"TABLE_InterconnectorFlowAtSingleTick", "DecarbonizationModel", "markets=g.idx('__types__')[[className:'emlab.gen.domain.market.electricity.ElectricitySpotMarket']].count();
results=[]
headers=['IC name','IC flow']
results.add(headers)
if((int)markets>1){
icpoints=g.idx('__types__')[[className:'emlab.gen.domain.market.electricity.YearlySegmentClearingPointInterconnectorInformation']].filter{it.time==0}
for(point in icpoints){
name=point.in('INTERCONNECTOR_INFORMATION_POINT').collect{it.name}[0]
for(int i=0;i<point.yearlyInterconnectorFlow.length;i++){
flow=point.yearlyInterconnectorFlow[i]
results.add([name,flow])
}
}
}
return results;",

"TABLE_CapacityinMW", "DecarbonizationModel", "ppdps= g.idx('__types__')[[className:'emlab.gen.domain.market.electricity.PpdpAnnual']].filter{it.time==tick}
finalResult = []
headers=['tick','market','technology','generation']
finalResult.add(headers)
for(ppdp in ppdps){
market=ppdp.out('BIDDINGMARKET').collect{it.name}[0]
technology=ppdp.out('PPDPANNUAL_POWERPLANT').out('TECHNOLOGY').collect{it.name}[0]
generation=ppdp.yearlySupply
finalResult.add([tick,market,technology,generation])
}
return finalResult;",

"TABLE_ProductionPerProducer", "DecarbonizationModel", "ppdps= g.idx('__types__')[[className:'emlab.gen.domain.market.electricity.PpdpAnnual']].filter{it.time==tick}
finalResult = []
headers=['tick','market','technology','generation']
finalResult.add(headers)
for(ppdp in ppdps){
market=ppdp.out('BIDDINGMARKET').collect{it.name}[0]
technology=ppdp.out('PPDPANNUAL_POWERPLANT').out('TECHNOLOGY').collect{it.name}[0]
generation=ppdp.yearlySupply
finalResult.add([tick,market,technology,generation])
}
return finalResult;",

"TABLE_Ppdp_Accepted", "DecarbonizationModel", "ppdps= g.idx('__types__')[[className:'emlab.gen.domain.market.electricity.PpdpAnnual']].filter{it.time==tick && it.status>=2}
finalResult = []
headers=['tick','producer','amount','price']
finalResult.add(headers)
for(ppdp in ppdps){
producer=ppdp.in('BIDDER').collect{it.name}[0]
price=ppdp.price
amount=ppdp.yearlySupply
finalResult.add([tick,producer,amount,price])
}
return finalResult;",

"TABLE_Ppdp_Failed", "DecarbonizationModel", "ppdps= g.idx('__types__')[[className:'emlab.gen.domain.market.electricity.PpdpAnnual']].filter{it.time==tick && it.status==-1}
finalResult = []
headers=['tick','producer','price']
finalResult.add(headers)
for(ppdp in ppdps){
producer=ppdp.in('BIDDER').collect{it.name}[0]
price=ppdp.price
finalResult.add([tick,producer,price])
}
return finalResult;",