"CapacityClearingPointPriceinEur", "DecarbonizationModel", "price = g.idx('__types__')[[className:'emlab.gen.domain.market.capacity.CapacityClearingPoint']].filter{it.time==tick}.price;
result=[]
for(p in price) result.add(p)
if(result.isEmpty()){return 0};
return result[0]",

"CapacityClearingPointVolumeinEur", "DecarbonizationModel", "volume = g.idx('__types__')[[className:'emlab.gen.domain.market.capacity.CapacityClearingPoint']].filter{it.time==tick}.volume;
result=[]
for(vl in volume) result.add(vl)
if(result.isEmpty()){return 0};
return result[0]",

"CapacityinMW", "PowerGeneratingTechnology", "capacity= v.in('TECHNOLOGY').filter{(it.dismantleTime > tick) && ((it.constructionStartTime + it.actualPermittime + it.actualLeadtime) <= tick)}.sum{it.actualNominalCapacity}
if(capacity == null) capacity = 0
[v.name, capacity]",

"CapacityinMWinA", "PowerGeneratingTechnology", "capacity = v.in('TECHNOLOGY').as('x').out('LOCATION').out('REGION').filter{it.name=='Country A'}.back('x').filter{(it.dismantleTime > tick) && ((it.constructionStartTime + it.actualPermittime + it.actualLeadtime) <= tick)}.sum{it.actualNominalCapacity}
if(capacity == null) capacity = 0
[v.name, capacity]",

"CapacityinMWinB", "PowerGeneratingTechnology", "capacity = v.in('TECHNOLOGY').as('x').out('LOCATION').out('REGION').filter{it.name=='Country B'}.back('x').filter{(it.dismantleTime > tick) && ((it.constructionStartTime + it.actualPermittime + it.actualLeadtime) <= tick)}.sum{it.actualNominalCapacity}
if(capacity == null) capacity = 0
[v.name, capacity]",

"CapacityinMWinC", "PowerGeneratingTechnology", "capacity = v.in('TECHNOLOGY').as('x').out('LOCATION').out('REGION').filter{it.name=='Country C'}.back('x').filter{(it.dismantleTime > tick) && ((it.constructionStartTime + it.actualPermittime + it.actualLeadtime) <= tick)}.sum{it.actualNominalCapacity}
if(capacity == null) capacity = 0
[v.name, capacity]",

"PeakDemandPerZoneInMW", "ElectricitySpotMarket", "topsegments = v.out('SEGMENT_LOAD').max{it.baseLoad}.baseLoad;
try{growthfactors = v.out('DEMANDGROWTH_TREND').collect{f.getTrendValue(it, tick)}[0];} catch(Exception e){    
growthfactors=v.out('DEMANDGROWTH_TREND').timeSeries.next()[tick.toInteger()]}
adjustedTopSegments = topsegments*growthfactors;
return [v.outE('ZONE').inV.collect{it.name}[0], adjustedTopSegments]",

"AnnualPeakDemandPerZoneInMW", "ElectricitySpotMarket", "topsegments = v.out('SEGMENT_LOAD').max{it.residualGLDC}.residualGLDC;
return [v.outE('ZONE').inV.collect{it.name}[0], topsegments]",

"TotalOperationalCapacityPerZoneInMW", "Zone", "t = new Table();
pp = v.in('REGION').in('LOCATION')
pp.filter{(it.dismantleTime > tick) && ((it.constructionStartTime + it.actualPermittime + it.actualLeadtime) <= tick)}.as('powerPlantCapacity').out('TECHNOLOGY').as('peakSegmentDependentAvailability').table(t){it.actualNominalCapacity}{it.peakSegmentDependentAvailability}.cap().next();
capacitySum = 0; for (row in t){capacitySum += row.getColumn('powerPlantCapacity') * row.getColumn('peakSegmentDependentAvailability')}
return [v.name, capacitySum]",

"TotalConsumptioninMWh", "DecarbonizationModel", "segmentloads = g.idx('__types__')[[className:'emlab.gen.domain.market.electricity.SegmentLoad']];
productionsum  = 0;
for(segmentload in segmentloads){
    productionsum += segmentload.out('SEGMENTLOAD_SEGMENT').lengthInHoursGLDCForInvestmentRole.next() * segmentload.residualGLDC ;
}
return productionsum;",

"TotalAnnualConsumptioninMWh", "DecarbonizationModel", "ppdps = g.idx('__types__')[[className:'emlab.gen.domain.market.electricity.PpdpAnnual']].filter{it.status == 2};
productionsum  = 0;
for(ppdp in ppdps){
    productionsum += ppdp.yearlySupply;
}
return productionsum;",

"CO2CapinTonpA", "Government", "try{cap = v.out('CO2CAP_TREND').collect{f.getTrendValue(it, tick)}[0];} catch(Exception e){
cap = v.out('CO2CAP_TREND').timeSeries.next()[tick.toInteger()];}
return ['CO2_cap', cap]",


"NationalMinCO2PriceinEURpTon", "NationalGovernment","try{price = v.out('MINCO2PRICE_TREND').collect{f.getTrendValue(it, tick)}[0];} catch(Exception e){  
price = v.out('MINCO2PRICE_TREND').timeSeries.next()[tick.toInteger()];}
return [v.out('GOVERNED_ZONE').collect{it.name}[0], price];",

"NationalGovernmentCash", "NationalGovernment","
return [v.out('GOVERNED_ZONE').collect{it.name}[0], v.cash];",

"EUGovernmentCash", "Government","
return v.cash;",

"SpotMarketCash", "ElectricitySpotMarket","
return [v.name, v.cash];",

"GenerationinMWh", "PowerGeneratingTechnology", "sum = 0;
ppdps = v.in('TECHNOLOGY').in('PPDPANNUAL_POWERPLANT').filter{it.time==tick && it.status>=2 && it.forecast==false}
for(ppdp in ppdps){
    totalAmount = ppdp.getProperty('yearlySupply');
    sum = sum + totalAmount;
}
return [v.name, sum]",

"AnnualGenerationinMWhPerProducer", "EnergyProducer", "sum = 0;
ppdps = v.in('POWERPLANT_OWNER').in('PPDPANNUAL_POWERPLANT').filter{it.time==tick && it.status>=2}
for(ppdp in ppdps){
    totalAmount = ppdp.getProperty('yearlySupply');
    sum = sum + totalAmount;
}
return [v.name, sum]",

"Avg_El_PricesinEURpMWh", "Zone", "cp = v.in('ZONE').out('MARKET_INFORMATION_POINT').filter{it.time==tick}
sum=0;
for(int i=0; i<=cp.marketPrice.length; i++){sum=sum+cp.marketPrice[i]};
return [v.name, sum / cp.marketPrice.length];",

"NationalTotalProductioninMWh", "Zone", "powerplants = v.in('REGION').in('LOCATION')
return [v.name, powerplants.in('PPDPANNUAL_POWERPLANT').sum{it.yearlySupply}]",

"Total_EnergyServedinMWh", "Zone", "cp = v.in('ZONE').in('MARKET_INFORMATION_POINT').filter{it.time==tick}
sum=0;
for(int i=0; i<=cp.marketSupply.length; i++){sum=sum+cp.marketSupply[i]};
return [v.name, sum];",

"Total_DemandinMWh", "Zone", "cp = v.in('ZONE').in('MARKET_INFORMATION_POINT').filter{it.time==tick}
demandsum  = 0;
for(int i=0; i<=cp.marketDemand.length; i++){demandsum=demandsum+cp.marketDemand[i]};
return [v.name, demandsum];",

"WelfareLossThroughENS", "Zone", "cp = v.in('ZONE').in('MARKET_INFORMATION_POINT').filter{it.time==tick}
volumeOfLostLoad  = 0;
for(int i=0; i<=cp.valueOfLostLoad.length; i++){volumeOfLostLoad=volumeOfLostLoad+cp.valueOfLostLoad[i]};
voll = v.in('ZONE').next().valueOfLostLoad
return [v.name, volumeOfLostLoad*voll];",

"EnergyNotServedinMWh", "Zone", "cp = v.in('ZONE').in('MARKET_INFORMATION_POINT').filter{it.time==tick}
volumeOfLostLoad  = 0;
for(int i=0; i<=cp.valueOfLostLoad.length; i++){volumeOfLostLoad=volumeOfLostLoad+cp.valueOfLostLoad[i]};
return [v.name, volumeOfLostLoad];",

"CO2Emissions_inTonpA", "DecarbonizationModel", "ppdps=g.idx('__types__')[[className:'emlab.gen.domain.market.electricity.PpdpAnnual']].propertyFilter('time', FilterPipe.Filter.EQUAL, tick).filter{it.status>=2}.collect();
co2Emissions = 0
for(plan in ppdps){
co2Emissions+=plan.yearlyEmissions;
}
return co2Emissions",

"CO2Emissions_inTonpA_perZone", "Zone", "ppdps=v.in('ZONE').in('REGION').in('LOCATION').in('PPDPANNUAL_POWERPLANT').propertyFilter('time', FilterPipe.Filter.EQUAL, tick).filter{it.status>=2}.collect();
co2Emissions = 0
for(plan in ppdps){
co2Emissions+=plan.yearlyEmissions;
}
return co2Emissions",

"EUCO2PriceFloor", "Government", "try{price = v.out('MINCO2PRICE_TREND').collect{f.getTrendValue(it, tick)}[0];} catch(Exception e){  
price = v.out('MINCO2PRICE_TREND').timeSeries.next()[tick.toInteger()];};
return ['EU CO2 price floor', price];",

"CO2Tax", "Government", "try{price = v.out('CO2TAX_TREND').collect{f.getTrendValue(it, tick)}[0];} catch(Exception e){  
price = v.out('CO2TAX_TREND').timeSeries.next()[tick.toInteger()];}
return price",

"FuelPricesPerGJ", "DecarbonizationModel", "fuels = g.idx('__types__')[[className:'emlab.gen.domain.technology.Substance']].filter{it.name != 'Electricity' && it.name != 'CO2'}
result = []
for(v in fuels){
      price = v.in('SUBSTANCE_MARKET').in('MARKET_POINT').filter{it.time == tick}.collect{it.price};
      density = v.energyDensity;
      inGJ = price[0] / density;
      result.add([v.name,inGJ]);}
      return result",

"ProducerCash", "EnergyProducer", "[v.name, v.cash]",

"HistoricalCVar", "PowerGeneratingTechnology", "fr = v.in('TECHNOLOGY').in('FINANCIALREPORT_POWERPLANT').propertyFilter('time', FilterPipe.Filter.GREATER_THAN_EQUAL, tick-2).propertyFilter('time', FilterPipe.Filter.LESS_THAN_EQUAL, tick).propertyFilter('powerPlantStatus', FilterPipe.Filter.EQUAL, 1);
cvar=0;
if(fr.hasNext()){fr=fr.sort{it.overallRevenue-it.variableCosts}._().toList();
length=fr.size(); fiveQuantile=(int)length*0.05;cvar=(long) 0;
for(int i=0; i<=fiveQuantile; i++){cvar=cvar+(fr[i].overallRevenue-fr[i].variableCosts)/fr[i].out('FINANCIALREPORT_POWERPLANT').actualNominalCapacity.next()};
cvar=cvar/((double)(fiveQuantile+1));}
return [v.name,cvar];",

"AggregateFinances", "DecarbonizationModel", "flows = n.getNodes('CashFlow');
groups = flows.groupBy{it.type}
result = [];
totalCosts = 0;
totalRevenue = 0;
totalSpotRevenue = 0;
totalLTCRevenue = 0;
totalCMRevenue = 0;
totalRESRevenue=0;
totalCO2HedgingRevenue=0;
totalTargetInvCosts = 0;
totalTargetInvRevenue = 0;
totalTargetInvSpotRevenue = 0;
totalTargetInvLTCRevenue = 0;
totalTargetInvCMRevenue = 0;
totalTargetInvRESRevenue=0;
totalTargetInvCO2HedgingRevenue=0;
hedgingFlows=[]
for (key in groups.keySet()) {
    if (key<3 || (key>9 && key!=12)) {
        for (flow in groups[key]) {
            if (flow.time != tick) continue;
            if (flow.out('TO_AGENT').collect{it.__type__.contains('EnergyProducer')}[0]) {
                totalRevenue += flow.money;
            } else if(flow.out('TO_AGENT').collect{it.__type__.contains('TargetInvestor')}[0]){
                totalTargetInvRevenue += flow.money;
            }
        }
        
    } else if(key!=12) {
        for (flow in groups[key]) {
            if (flow.time != tick) continue;
            if (flow.out('FROM_AGENT').collect{it.__type__.contains('EnergyProducer')}[0]) {
                totalCosts += flow.money;
            } else if(flow.out('FROM_AGENT').collect{it.__type__.contains('TargetInvestor')}[0]){
                totalTargetInvCosts += flow.money;
            }
        }
    }
       
     if (key==1) {
        for (flow in groups[key]) {
            if (flow.time != tick) continue;
            if (flow.out('TO_AGENT').collect{it.__type__.contains('EnergyProducer')}[0]) {
                totalSpotRevenue += flow.money;
            } else if(flow.out('TO_AGENT').collect{it.__type__.contains('TargetInvestor')}[0]){
                totalTargetInvSpotRevenue += flow.money;
            }
        }
        
    }
    
     if (key==2) {
        for (flow in groups[key]) {
            if (flow.time != tick) continue;
            if (flow.out('TO_AGENT').collect{it.__type__.contains('EnergyProducer')}[0]) {
                totalLTCRevenue += flow.money;
            } else if(flow.out('TO_AGENT').collect{it.__type__.contains('TargetInvestor')}[0]){
                totalTargetInvLTCRevenue += flow.money;
            }
        }
        
    }
    
         if (key==11) {
        for (flow in groups[key]) {
            if (flow.time != tick) continue;
            if (flow.out('TO_AGENT').collect{it.__type__.contains('EnergyProducer')}[0]) {
                totalCMRevenue += flow.money;
            } else if(flow.out('TO_AGENT').collect{it.__type__.contains('TargetInvestor')}[0]){
                totalTargetInvCMRevenue += flow.money;
            }
        }
        
    }
    
        
             if (key==10) {
        for (flow in groups[key]) {
            if (flow.time != tick) continue;
            if (flow.out('TO_AGENT').collect{it.__type__.contains('EnergyProducer')}[0]) {
                totalRESRevenue += flow.money;
            } else if(flow.out('TO_AGENT').collect{it.__type__.contains('TargetInvestor')}[0]){
                totalTargetInvRESRevenue += flow.money;
            }
        }
        
    }

if (key==12) {
        for (flow in groups[key]) {
            if (flow.time != tick) continue;
            hedgingFlows.add(flow)
            if (flow.out('TO_AGENT').collect{it.__type__.contains('EnergyProducer')}[0])  {
                totalCO2HedgingRevenue += flow.money;
                totalRevenue+= flow.money;
            } else if(flow.out('TO_AGENT').collect{it.__type__.contains('TargetInvestor')}[0]){
                totalTargetInvCO2HedgingRevenue += flow.money;
            }
            if (flow.out('FROM_AGENT').collect{it.__type__.contains('EnergyProducer') }[0]) {
                //totalCO2HedgingRevenue -= flow.money;
                totalCosts+= flow.money;
            }
        }
        }

}
result.add(['Total Revenue', totalRevenue]);
result.add(['Revenue LTC', totalLTCRevenue]);
result.add(['Revenue Spot', totalSpotRevenue]);
result.add(['Revenue CM', totalCMRevenue])
result.add(['Revenue RES',totalRESRevenue])
result.add(['Revenue CO2Hedge', totalCO2HedgingRevenue]);
result.add(['Profit', totalRevenue - totalCosts]);
result.add(['TI Revenue', totalTargetInvRevenue]);
result.add(['TI Revenue LTC', totalTargetInvLTCRevenue]);
result.add(['TI Revenue Spot', totalTargetInvSpotRevenue]);
result.add(['TI Revenue CM', totalTargetInvCMRevenue])
result.add(['TI Revenue RES',totalTargetInvRESRevenue])
result.add(['TI Revenue CO2Hedge', totalTargetInvCO2HedgingRevenue]);
result.add(['TI Profit', totalTargetInvRevenue - totalTargetInvCosts]);
return result;",

"CountryAProdFinances", "DecarbonizationModel", "flows = n.getNodes('CashFlow');
groups = flows.groupBy{it.type}
result = [];
totalCosts = 0;
totalRevenue = 0;
totalSpotRevenue = 0;
totalLTCRevenue = 0;
totalCMRevenue = 0;
totalRESRevenue=0;
totalCO2HedgingRevenue=0;
totalTargetInvCosts = 0;
totalTargetInvRevenue = 0;
totalTargetInvSpotRevenue = 0;
totalTargetInvLTCRevenue = 0;
totalTargetInvCMRevenue = 0;
totalTargetInvRESRevenue=0;
totalTargetInvCO2HedgingRevenue=0;
hedgingFlows=[]
for (key in groups.keySet()) {
    if (key<3 || (key>9 && key!=12)) {
        for (flow in groups[key]) {
            if (flow.time != tick) continue;
            if (flow.out('TO_AGENT').collect{it.__type__.contains('EnergyProducer')}[0] && flow.out('TO_AGENT').out('INVESTOR_MARKET').out('ZONE').collect{it.name.equals('Country A')}[0]) {
                totalRevenue += flow.money;
            } else if(flow.out('TO_AGENT').collect{it.__type__.contains('TargetInvestor') }[0] && flow.out('TO_AGENT').out('INVESTOR_MARKET').out('ZONE').collect{it.name.equals('Country A')}[0]){
                totalTargetInvRevenue += flow.money;
            }
        }
        
    } else if(key!=12) {
        for (flow in groups[key]) {
            if (flow.time != tick) continue;
            if (flow.out('FROM_AGENT').collect{it.__type__.contains('EnergyProducer')}[0] && flow.out('FROM_AGENT').out('INVESTOR_MARKET').out('ZONE').collect{it.name.equals('Country A')}[0]) {
                totalCosts += flow.money;
            } else if(flow.out('FROM_AGENT').collect{it.__type__.contains('TargetInvestor') }[0] && flow.out('FROM_AGENT').out('INVESTOR_MARKET').out('ZONE').collect{it.name.equals('Country A')}[0]){
                totalTargetInvCosts += flow.money;
            }
        }
    }
       
     if (key==1) {
        for (flow in groups[key]) {
            if (flow.time != tick) continue;
            if (flow.out('TO_AGENT').collect{it.__type__.contains('EnergyProducer')}[0] && flow.out('TO_AGENT').out('INVESTOR_MARKET').out('ZONE').collect{it.name.equals('Country A')}[0]) {
                totalSpotRevenue += flow.money;
            } else if(flow.out('TO_AGENT').collect{it.__type__.contains('TargetInvestor') }[0] && flow.out('TO_AGENT').out('INVESTOR_MARKET').out('ZONE').collect{it.name.equals('Country A')}[0]){
                totalTargetInvSpotRevenue += flow.money;
            }
        }
        
    }
    
     if (key==2) {
        for (flow in groups[key]) {
            if (flow.time != tick) continue;
            if (flow.out('TO_AGENT').collect{it.__type__.contains('EnergyProducer')}[0] && flow.out('TO_AGENT').out('INVESTOR_MARKET').out('ZONE').collect{it.name.equals('Country A')}[0]) {
                totalLTCRevenue += flow.money;
            } else if(flow.out('TO_AGENT').collect{it.__type__.contains('TargetInvestor') }[0] && flow.out('TO_AGENT').out('INVESTOR_MARKET').out('ZONE').collect{it.name.equals('Country A')}[0]){
                totalTargetInvLTCRevenue += flow.money;
            }
        }
        
    }
    
         if (key==11) {
        for (flow in groups[key]) {
            if (flow.time != tick) continue;
            if (flow.out('TO_AGENT').collect{it.__type__.contains('EnergyProducer')}[0] && flow.out('TO_AGENT').out('INVESTOR_MARKET').out('ZONE').collect{it.name.equals('Country A')}[0]) {
                totalCMRevenue += flow.money;
            } else if(flow.out('TO_AGENT').collect{it.__type__.contains('TargetInvestor') }[0] && flow.out('TO_AGENT').out('INVESTOR_MARKET').out('ZONE').collect{it.name.equals('Country A')}[0]){
                totalTargetInvCMRevenue += flow.money;
            }
        }
        
    }
    
        
             if (key==10) {
        for (flow in groups[key]) {
            if (flow.time != tick) continue;
            if (flow.out('TO_AGENT').collect{it.__type__.contains('EnergyProducer')}[0] && flow.out('TO_AGENT').out('INVESTOR_MARKET').out('ZONE').collect{it.name.equals('Country A')}[0]) {
                totalRESRevenue += flow.money;
            } else if(flow.out('TO_AGENT').collect{it.__type__.contains('TargetInvestor') }[0] && flow.out('TO_AGENT').out('INVESTOR_MARKET').out('ZONE').collect{it.name.equals('Country A')}[0]){
                totalTargetInvRESRevenue += flow.money;
            }
        }
        
    }

if (key==12) {
        for (flow in groups[key]) {
            if (flow.time != tick) continue;
            hedgingFlows.add(flow)
            if (flow.out('TO_AGENT').collect{it.__type__.contains('EnergyProducer')}[0] && flow.out('TO_AGENT').out('INVESTOR_MARKET').out('ZONE').collect{it.name.equals('Country A')}[0])  {
                totalCO2HedgingRevenue += flow.money;
                totalRevenue+= flow.money;
            } else if(flow.out('TO_AGENT').collect{it.__type__.contains('TargetInvestor') }[0] && flow.out('TO_AGENT').out('INVESTOR_MARKET').out('ZONE').collect{it.name.equals('Country A')}[0]){
                totalTargetInvCO2HedgingRevenue += flow.money;
            }
            if (flow.out('FROM_AGENT').collect{it.__type__.contains('EnergyProducer') }[0] && flow.out('FROM_AGENT').out('INVESTOR_MARKET').out('ZONE').collect{it.name.equals('Country A')}[0]) {
                totalCO2HedgingRevenue -= flow.money;
                totalCosts+= flow.money;
            }
        }
        }

}
result.add(['Total Revenue', totalRevenue]);
result.add(['Revenue LTC', totalLTCRevenue]);
result.add(['Revenue Spot', totalSpotRevenue]);
result.add(['Revenue CM', totalCMRevenue])
result.add(['Revenue RES',totalRESRevenue])
result.add(['Revenue CO2Hedge', totalCO2HedgingRevenue]);
result.add(['Profit', totalRevenue - totalCosts]);
result.add(['TI Revenue', totalTargetInvRevenue]);
result.add(['TI Revenue LTC', totalTargetInvLTCRevenue]);
result.add(['TI Revenue Spot', totalTargetInvSpotRevenue]);
result.add(['TI Revenue CM', totalTargetInvCMRevenue])
result.add(['TI Revenue RES',totalTargetInvRESRevenue])
result.add(['TI Revenue CO2Hedge', totalTargetInvCO2HedgingRevenue]);
result.add(['TI Profit', totalTargetInvRevenue - totalTargetInvCosts]);
return result;
",

"CountryBProdFinances", "DecarbonizationModel", "flows = n.getNodes('CashFlow');
groups = flows.groupBy{it.type}
result = [];
totalCosts = 0;
totalRevenue = 0;
totalSpotRevenue = 0;
totalLTCRevenue = 0;
totalCMRevenue = 0;
totalRESRevenue=0;
totalCO2HedgingRevenue=0;
totalTargetInvCosts = 0;
totalTargetInvRevenue = 0;
totalTargetInvSpotRevenue = 0;
totalTargetInvLTCRevenue = 0;
totalTargetInvCMRevenue = 0;
totalTargetInvRESRevenue=0;
totalTargetInvCO2HedgingRevenue=0;
hedgingFlows=[]
for (key in groups.keySet()) {
    if (key<3 || (key>9 && key!=12)) {
        for (flow in groups[key]) {
            if (flow.time != tick) continue;
            if (flow.out('TO_AGENT').collect{it.__type__.contains('EnergyProducer')}[0] && flow.out('TO_AGENT').out('INVESTOR_MARKET').out('ZONE').collect{it.name.equals('Country B')}[0]) {
                totalRevenue += flow.money;
            } else if(flow.out('TO_AGENT').collect{it.__type__.contains('TargetInvestor') }[0] && flow.out('TO_AGENT').out('INVESTOR_MARKET').out('ZONE').collect{it.name.equals('Country B')}[0]){
                totalTargetInvRevenue += flow.money;
            }
        }
        
    } else if(key!=12) {
        for (flow in groups[key]) {
            if (flow.time != tick) continue;
            if (flow.out('FROM_AGENT').collect{it.__type__.contains('EnergyProducer')}[0] && flow.out('FROM_AGENT').out('INVESTOR_MARKET').out('ZONE').collect{it.name.equals('Country B')}[0]) {
                totalCosts += flow.money;
            } else if(flow.out('FROM_AGENT').collect{it.__type__.contains('TargetInvestor') }[0] && flow.out('FROM_AGENT').out('INVESTOR_MARKET').out('ZONE').collect{it.name.equals('Country B')}[0]){
                totalTargetInvCosts += flow.money;
            }
        }
    }
       
     if (key==1) {
        for (flow in groups[key]) {
            if (flow.time != tick) continue;
            if (flow.out('TO_AGENT').collect{it.__type__.contains('EnergyProducer')}[0] && flow.out('TO_AGENT').out('INVESTOR_MARKET').out('ZONE').collect{it.name.equals('Country B')}[0]) {
                totalSpotRevenue += flow.money;
            } else if(flow.out('TO_AGENT').collect{it.__type__.contains('TargetInvestor') }[0] && flow.out('TO_AGENT').out('INVESTOR_MARKET').out('ZONE').collect{it.name.equals('Country B')}[0]){
                totalTargetInvSpotRevenue += flow.money;
            }
        }
        
    }
    
     if (key==2) {
        for (flow in groups[key]) {
            if (flow.time != tick) continue;
            if (flow.out('TO_AGENT').collect{it.__type__.contains('EnergyProducer')}[0] && flow.out('TO_AGENT').out('INVESTOR_MARKET').out('ZONE').collect{it.name.equals('Country B')}[0]) {
                totalLTCRevenue += flow.money;
            } else if(flow.out('TO_AGENT').collect{it.__type__.contains('TargetInvestor') }[0] && flow.out('TO_AGENT').out('INVESTOR_MARKET').out('ZONE').collect{it.name.equals('Country B')}[0]){
                totalTargetInvLTCRevenue += flow.money;
            }
        }
        
    }
    
         if (key==11) {
        for (flow in groups[key]) {
            if (flow.time != tick) continue;
            if (flow.out('TO_AGENT').collect{it.__type__.contains('EnergyProducer')}[0] && flow.out('TO_AGENT').out('INVESTOR_MARKET').out('ZONE').collect{it.name.equals('Country B')}[0]) {
                totalCMRevenue += flow.money;
            } else if(flow.out('TO_AGENT').collect{it.__type__.contains('TargetInvestor') }[0] && flow.out('TO_AGENT').out('INVESTOR_MARKET').out('ZONE').collect{it.name.equals('Country B')}[0]){
                totalTargetInvCMRevenue += flow.money;
            }
        }
        
    }
    
        
             if (key==10) {
        for (flow in groups[key]) {
            if (flow.time != tick) continue;
            if (flow.out('TO_AGENT').collect{it.__type__.contains('EnergyProducer')}[0] && flow.out('TO_AGENT').out('INVESTOR_MARKET').out('ZONE').collect{it.name.equals('Country B')}[0]) {
                totalRESRevenue += flow.money;
            } else if(flow.out('TO_AGENT').collect{it.__type__.contains('TargetInvestor') }[0] && flow.out('TO_AGENT').out('INVESTOR_MARKET').out('ZONE').collect{it.name.equals('Country B')}[0]){
                totalTargetInvRESRevenue += flow.money;
            }
        }
        
    }

if (key==12) {
        for (flow in groups[key]) {
            if (flow.time != tick) continue;
            hedgingFlows.add(flow)
            if (flow.out('TO_AGENT').collect{it.__type__.contains('EnergyProducer')}[0] && flow.out('TO_AGENT').out('INVESTOR_MARKET').out('ZONE').collect{it.name.equals('Country B')}[0])  {
                totalCO2HedgingRevenue += flow.money;
                totalRevenue+= flow.money;
            } else if(flow.out('TO_AGENT').collect{it.__type__.contains('TargetInvestor') }[0] && flow.out('TO_AGENT').out('INVESTOR_MARKET').out('ZONE').collect{it.name.equals('Country B')}[0]){
                totalTargetInvCO2HedgingRevenue += flow.money;
            }
            if (flow.out('FROM_AGENT').collect{it.__type__.contains('EnergyProducer') }[0] && flow.out('FROM_AGENT').out('INVESTOR_MARKET').out('ZONE').collect{it.name.equals('Country B')}[0]) {
                totalCO2HedgingRevenue -= flow.money;
                totalCosts+= flow.money;
            }
        }
        }

}
result.add(['Total Revenue', totalRevenue]);
result.add(['Revenue LTC', totalLTCRevenue]);
result.add(['Revenue Spot', totalSpotRevenue]);
result.add(['Revenue CM', totalCMRevenue])
result.add(['Revenue RES',totalRESRevenue])
result.add(['Revenue CO2Hedge', totalCO2HedgingRevenue]);
result.add(['Profit', totalRevenue - totalCosts]);
result.add(['TI Revenue', totalTargetInvRevenue]);
result.add(['TI Revenue LTC', totalTargetInvLTCRevenue]);
result.add(['TI Revenue Spot', totalTargetInvSpotRevenue]);
result.add(['TI Revenue CM', totalTargetInvCMRevenue])
result.add(['TI Revenue RES',totalTargetInvRESRevenue])
result.add(['TI Revenue CO2Hedge', totalTargetInvCO2HedgingRevenue]);
result.add(['TI Profit', totalTargetInvRevenue - totalTargetInvCosts]);
return result;",

"PriceInEURperMWh", "DecarbonizationModel", "results = []
points = g.idx('__types__')[[className:'emlab.gen.domain.market.electricity.SegmentClearingPoint']].propertyFilter('time', FilterPipe.Filter.EQUAL, tick).propertyFilter('forecast', FilterPipe.Filter.EQUAL, false)
for(scp in points){
    results.add(['Segment ' + scp.out('MARKET_POINT').out('ZONE').name.next() + ' ' + scp.out('SEGMENT_POINT').segmentID.next(), scp.price])
}
return results",

"ShortagesInHoursUnserved", "DecarbonizationModel", "powerplants = g.idx('__types__')[[className:'emlab.gen.domain.technology.PowerPlant']].filter{(it.dismantleTime > tick) && ((it.constructionStartTime + it.actualPermittime + it.actualLeadtime) <= tick)}
production= powerplants.in('POWERPLANT_DISPATCHPLAN').sum{f.determineProductionOfDispatchPlanInMWh(it, tick)};
segmentloads = g.idx('__types__')[[className:'emlab.gen.domain.market.electricity.SegmentLoad']]
productionsum  = 0;
for(segmentload in segmentloads){
    try{growthfactor = segmentload.in('SEGMENT_LOAD').out('DEMANDGROWTH_TREND').collect{f.getTrendValue(it, tick)}[0];} catch(Exception e){  
    growthfactor=segmentload.in('SEGMENT_LOAD').out('DEMANDGROWTH_TREND').timeSeries.next()[tick.toInteger()]}    
    productionsum += segmentload.out('SEGMENTLOAD_SEGMENT').lengthInHours.next() * segmentload.baseLoad * growthfactor;
}
return (production-productionsum)/productionsum*8760;",

"ProducerCosts", "DecarbonizationModel", "flows = n.getNodes('CashFlow');
groups = flows.groupBy{it.type}
result = [];
allKeys = []
for(i in 0..12)
    allKeys.add(i)
usedKeys=[]
for (key in allKeys) {
    usedKeys.add(key)
    sum = 0;
    if(key in groups.keySet()){
         for (flow in groups[key]) {
        if (flow.time != tick) continue;
        if (flow.out('FROM_AGENT').collect{it.__type__.contains('EnergyProducer')}[0]) {
            sum += flow.money;
            }
        }
    } 
    name='Unspecified';
    if(key==0){name='Unclassified';}
    if(key==1){name='Electricity spot';}
    if(key==2){name='Electricity ltc';}
    if(key==3){name='Fixed O&M';}
    if(key==4){name='Commodity';}
    if(key==5){name='CO2 tax';}
    if(key==6){name='CO2 auction';}
    if(key==7){name='Loan';}
    if(key==8){name='Downpayment';}
    if(key==9){name='National CO2 MinPrice';}
    if(key==10){name='Strategic Reserve';}
    if(key==11){name='Capacity Market';}
    if(key==12){name='CO2 Hedging';}
    result.add([name, sum]);
} 
return result;",

"CountryAProdCosts", "DecarbonizationModel", "flows = n.getNodes('CashFlow');
groups = flows.groupBy{it.type}
result = [];
allKeys = []
for(i in 0..12)
    allKeys.add(i)
usedKeys=[]
for (key in allKeys) {
    usedKeys.add(key)
    sum = 0;
    if(key in groups.keySet()){
         for (flow in groups[key]) {
        if (flow.time != tick) continue;
        if (flow.out('FROM_AGENT').collect{it.__type__.contains('EnergyProducer')}[0] && flow.out('FROM_AGENT').out('INVESTOR_MARKET').out('ZONE').collect{it.name.equals('Country A')}[0]) {
            sum += flow.money;
            }
        }
    } 
    name='Unspecified';
    if(key==0){name='Unclassified';}
    if(key==1){name='Electricity spot';}
    if(key==2){name='Electricity ltc';}
    if(key==3){name='Fixed O&M';}
    if(key==4){name='Commodity';}
    if(key==5){name='CO2 tax';}
    if(key==6){name='CO2 auction';}
    if(key==7){name='Loan';}
    if(key==8){name='Downpayment';}
    if(key==9){name='National CO2 MinPrice';}
    if(key==10){name='Strategic Reserve';}
    if(key==11){name='Capacity Market';}
    if(key==12){name='CO2 Hedging';}
    result.add([name, sum]);
} 
return result;",

"CountryBProdCosts", "DecarbonizationModel", "flows = n.getNodes('CashFlow');
groups = flows.groupBy{it.type}
result = [];
allKeys = []
for(i in 0..12)
    allKeys.add(i)
usedKeys=[]
for (key in allKeys) {
    usedKeys.add(key)
    sum = 0;
    if(key in groups.keySet()){
         for (flow in groups[key]) {
        if (flow.time != tick) continue;
        if (flow.out('FROM_AGENT').collect{it.__type__.contains('EnergyProducer')}[0] && flow.out('FROM_AGENT').out('INVESTOR_MARKET').out('ZONE').collect{it.name.equals('Country B')}[0]) {
            sum += flow.money;
            }
        }
    } 
    name='Unspecified';
    if(key==0){name='Unclassified';}
    if(key==1){name='Electricity spot';}
    if(key==2){name='Electricity ltc';}
    if(key==3){name='Fixed O&M';}
    if(key==4){name='Commodity';}
    if(key==5){name='CO2 tax';}
    if(key==6){name='CO2 auction';}
    if(key==7){name='Loan';}
    if(key==8){name='Downpayment';}
    if(key==9){name='National CO2 MinPrice';}
    if(key==10){name='Strategic Reserve';}
    if(key==11){name='Capacity Market';}
    if(key==12){name='CO2 Hedging';}
    result.add([name, sum]);
} 
return result;",

"TABLE_SegmentClearingPoints", "DecarbonizationModel", "points = g.idx('__types__')[[className:'emlab.gen.domain.market.electricity.SegmentClearingPoint']].propertyFilter('time', FilterPipe.Filter.EQUAL, tick).propertyFilter('forecast', FilterPipe.Filter.EQUAL, false)
finalResult = []
headers=['tick','volume','price','market','segmentID','segmentLength','interconectorFlow','demand','energynotserved']
finalResult.add(headers)
for(v in points){
market=v.out('MARKET_POINT')
segment=v.out('SEGMENT_POINT').next()
segmentId=segment.segmentID
segmentLoad=market.out('SEGMENT_LOAD').as('x').out('SEGMENTLOAD_SEGMENT').filter{it.segmentID==segmentId}.back('x').next();
//return segmentLoad.in('SEGMENT_LOAD').out('DEMANDGROWTH_TREND').timeSeries.next()[tick.toInteger()]
//return segmentLoad.in('SEGMENT_LOAD').out('DEMANDGROWTH_TREND').next().timeSeries[tick.toInteger()]
growthfactor=1
try{growthfactor = segmentLoad.in('SEGMENT_LOAD').out('DEMANDGROWTH_TREND').collect{f.getTrendValue(it, tick)}[0];} catch(Exception e){  
  growthfactor=segmentLoad.in('SEGMENT_LOAD').out('DEMANDGROWTH_TREND').next().timeSeries[tick.toInteger()]}
//}
//return segmentLoad
demandLevel=segmentLoad.out('SEGMENTLOAD_SEGMENT').lengthInHours.next() * segmentLoad.baseLoad * growthfactor;
    finalResult.add([v.time, v.volume, v.price, v.out('MARKET_POINT').collect{it.name}[0], v.out('SEGMENT_POINT').collect{it.segmentID}[0], v.out('SEGMENT_POINT').collect{it.lengthInHours}[0],v.interconnectorFlow,demandLevel,demandLevel-v.volume])
}
return finalResult;
",

"TABLE_ClearingPoints", "DecarbonizationModel", "points = g.idx('__types__')[[className:'emlab.gen.domain.market.ClearingPoint']].propertyFilter('time', FilterPipe.Filter.EQUAL, tick).propertyFilter('forecast', FilterPipe.Filter.EQUAL, false)
finalResult = []
headers=['tick','volume','price',',market']
finalResult.add(headers)
for(v in points){
finalResult.add([v.time, v.volume, v.price, v.out('MARKET_POINT').collect{it.name}[0]])
}
return finalResult",

"TABLE_InitialPowerPlants", "DecarbonizationModel", "if(tick<1){
powerPlants=g.idx('__types__')[[className:'emlab.gen.domain.technology.PowerPlant']];
finalResult = [];
columnNames=['Name', 'Technology', 'Location', 'Age', 'Owner', 'Capacity', 'Efficiency']
finalResult.add(columnNames)
for(p in powerPlants){
name = p.name
technology = p.out('TECHNOLOGY').collect{it.name}[0]
location = p.out('LOCATION').collect{it.name}[0]
age = -p.constructionStartTime-p.actualLeadtime-p.actualPermittime
owner = p.out('POWERPLANT_OWNER').collect{it.name}[0]
capacity = p.actualNominalCapacity
efficiency = p.actualEfficiency
finalResult.add([name,technology,location,age,owner,capacity,efficiency])
}
return finalResult
}",

"TABLE_FinancialReports", "DecarbonizationModel", "financialReports=g.idx('__types__')[[className:'emlab.gen.domain.market.electricity.FinancialPowerPlantReport']].filter{it.time==tick};
finalResult = [];
columnNames=['tick', 'spotMarketRevenue', 'capacityMarketRevenue', 'strategicReserveRevenue', 'co2HedgingRevenue', 'overallRevenue','commodityCosts','co2Costs','variableCosts','fixedCosts','fullLoadHours','production','powerPlantName','technology','location','powerPlantOwner','operationalStatus','firstYearOfPowerPlantOperation','nominalCapacity','investedCapital'];
finalResult.add(columnNames);
for(v in financialReports){
firstYearOfOperation=v.out('FINANCIALREPORT_POWERPLANT').constructionStartTime.next()+v.out('FINANCIALREPORT_POWERPLANT').actualPermittime.next()+v.out('FINANCIALREPORT_POWERPLANT').actualLeadtime.next()
powerPlantSize=v.out('FINANCIALREPORT_POWERPLANT').actualNominalCapacity.next()
actualInvestedCapital=v.out('FINANCIALREPORT_POWERPLANT').actualInvestedCapital.next()
finalResult.add([v.time, v.spotMarketRevenue, v.capacityMarketRevenue, v.strategicReserveRevenue, v.co2HedgingRevenue, v.overallRevenue, v.commodityCosts, v.co2Costs, v.variableCosts, v.fixedCosts, v.fullLoadHours, v.production, v.out('FINANCIALREPORT_POWERPLANT').name.next(),v.out('FINANCIALREPORT_POWERPLANT').out('TECHNOLOGY').name.next(),v.out('FINANCIALREPORT_POWERPLANT').out('LOCATION').name.next(),v.out('FINANCIALREPORT_POWERPLANT').out('POWERPLANT_OWNER').name.next(),v.powerPlantStatus,firstYearOfOperation,powerPlantSize,actualInvestedCapital]);
};
return finalResult;",